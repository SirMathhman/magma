#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
#include <temp.h>
struct Main {
		SOURCE_DIRECTORY  = temp;
		TARGET_DIRECTORY  = temp;
	void main(){
		temp();
	}
	IOException> collect(){
		temp = temp;
		temp = temp;
	}
	Optional<ApplicationError> runWithSources(){
		temp = temp;
		temp();
	}
	Optional<ApplicationError> runWithSource(){
		temp();
		temp();
		temp();
		temp();
		temp();
		temp = temp;
		return value;
		temp();
	}
	IOException> readStringWrapped(){
		temp = temp;
		temp = temp;
	}
	Optional<IOException> createDirectoriesWrapped(){
		temp = temp;
		temp = temp;
	}
	Optional<IOException> writeStringWrapped(){
		temp = temp;
		temp = temp;
	}
	CompileError> splitAndCompile(){
		return value;
		temp();
	}
	CompileError> split(){
		temp();
		temp();
		temp = temp;
		temp();
		temp = temp;
		temp();
		temp = temp;
		temp = temp;
	}
	void advance(){
		temp();
	}
	CompileError> compileRootSegment(){
		temp();
	}
	CompileError> or(){
		temp();
	}
	CompileError> compileNamespaced(){
		temp();
		temp();
	}
	List<CompileError> merge(){
		temp();
		temp();
		temp();
		temp();
		return value;
	}
	CompileError> compileToStruct(){
		return value;
		temp();
	}
	CompileError> compileStructSegment(){
		return value;
		temp();
	}
	CompileError> compileMethod(){
		return value;
		temp();
	}
	CompileError> compileStatement(){
		temp();
	}
	String generateStatement(){
		return value;
	}
	CompileError> truncateLeft(){
		temp();
		temp();
	}
	CompileError> compileDefinition(){
		return value;
		temp();
	}
	boolean isSymbol(){
		temp = temp;
		temp();
		temp = temp;
		return value;
	}
	String generateDefinition(){
		return value;
	}
	CompileError> truncateRight(){
		temp = temp;
		temp = temp;
	}
	CompileError> split(){
		return value;
		temp();
	}
	List<CompileError>>> prepare(){
		temp();
	}
};