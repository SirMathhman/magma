{
"children": [package {
 "namespace": ["magma.app.compile.lang"]
 }, import {
 "namespace": ["magma.api.Tuple"]
 }, import {
 "namespace": ["magma.app.compile.rule.Splitter"]
 }, import {
 "namespace": ["magma.java.JavaCollectors"]
 }, import {
 "namespace": ["java.util.LinkedList"]
 }, import {
 "namespace": ["java.util.List"]
 }, import {
 "namespace": ["java.util.Optional"]
 }, import {
 "namespace": ["java.util.stream.Collectors"]
 }, import {
 "namespace": ["java.util.stream.IntStream"]
 }, class {
 "name": "ValueSplitter implements Splitter ",
 "children": [method {
  "name": "splitAtChar",
  "returns": symbol {
   "value": "BufferedState"
   },
  "children": [return {
   "value": invocation {
    "caller": property-access {
     "child": "orElseGet",
     "parent": invocation {
      "caller": property-access {
       "child": "or",
       "parent": invocation {
        "caller": property-access {
         "child": "or",
         "parent": invocation {
          "caller": symbol {
           "content": "processDoubleQuotes"
           },
          "arguments": [symbol {
           "content": "current"
           }, symbol {
           "content": "c"
           }]
          }
         },
        "arguments": [invocation {
         "caller": lambda {
          "before-arrow": "() ",
          "after-arrow": " processMinusSign"
          },
         "arguments": [symbol {
          "content": "current"
          }, symbol {
          "content": "c"
          }]
         }]
        }
       },
      "arguments": [invocation {
       "caller": lambda {
        "before-arrow": "() ",
        "after-arrow": " processComma"
        },
       "arguments": [symbol {
        "content": "current"
        }, symbol {
        "content": "c"
        }]
       }]
      }
     },
    "arguments": [invocation {
     "caller": lambda {
      "before-arrow": "() ",
      "after-arrow": " processNormal"
      },
     "arguments": [symbol {
      "content": "current"
      }, symbol {
      "content": "c"
      }]
     }]
    }
   }, whitespace {
   }],
  "modifiers": [modifier {
   "modifier-value": "private"
   }, modifier {
   "modifier-value": "static"
   }],
  "params": [definition {
   "name": "current",
   "returns": symbol {
    "value": "BufferedState"
    }
   }, definition {
   "name": "c",
   "returns": symbol {
    "value": "Character"
    }
   }]
  }, method {
  "name": "processNormal",
  "returns": symbol {
   "value": "BufferedState"
   },
  "children": [declaration {
   "name": "appended",
   "caller": property-access {
    "child": "append",
    "parent": symbol {
     "content": "current"
     }
    },
   "returns": symbol {
    "value": "var"
    },
   "arguments": [symbol {
    "content": "c"
    }],
   "modifiers": [modifier {
    "modifier-value": "final"
    }]
   }, if {
   "content": " (c == '<' || c == '(') return appended.withDepth(current.depth() + 1);"
   }, if {
   "content": " (c == '>' || c == ')') return appended.withDepth(current.depth() - 1);"
   }, return {
   "value": symbol {
    "content": "appended"
    }
   }, whitespace {
   }],
  "modifiers": [modifier {
   "modifier-value": "private"
   }, modifier {
   "modifier-value": "static"
   }],
  "params": [definition {
   "name": "current",
   "returns": symbol {
    "value": "BufferedState"
    }
   }, definition {
   "name": "c",
   "returns": symbol {
    "value": "Character"
    }
   }]
  }, method {
  "name": "processComma",
  "returns": generic {
   "base": symbol {
    "value": "Optional"
    },
   "children": [symbol {
    "value": "BufferedState"
    }]
   },
  "children": [if {
   "content": " (c == ',' && current.isLevel()) {
            return Optional.of(current.advance());
        }"
   }, else {
   "children": [return {
    "value": invocation {
     "caller": property-access {
      "child": "empty",
      "parent": symbol {
       "content": "Optional"
       }
      }
     }
    }, whitespace {
    }]
   }, whitespace {
   }],
  "modifiers": [modifier {
   "modifier-value": "private"
   }, modifier {
   "modifier-value": "static"
   }],
  "params": [definition {
   "name": "current",
   "returns": symbol {
    "value": "BufferedState"
    }
   }, definition {
   "name": "c",
   "returns": symbol {
    "value": "char"
    }
   }]
  }, method {
  "name": "processMinusSign",
  "returns": generic {
   "base": symbol {
    "value": "Optional"
    },
   "children": [symbol {
    "value": "BufferedState"
    }]
   },
  "children": [if {
   "content": " (c != '-') return Optional.empty();"
   }, declaration {
   "name": "appended",
   "caller": property-access {
    "child": "append",
    "parent": symbol {
     "content": "current"
     }
    },
   "returns": symbol {
    "value": "var"
    },
   "arguments": [char {
    "value": "-"
    }],
   "modifiers": [modifier {
    "modifier-value": "final"
    }]
   }, declaration {
   "name": "peeked",
   "caller": property-access {
    "child": "peek",
    "parent": symbol {
     "content": "appended"
     }
    },
   "returns": symbol {
    "value": "var"
    },
   "modifiers": [modifier {
    "modifier-value": "final"
    }]
   }, if {
   "content": " (peeked.isEmpty() || peeked.get() != '>') return Optional.of(appended);"
   }, return {
   "value": invocation {
    "caller": property-access {
     "child": "map",
     "parent": invocation {
      "caller": property-access {
       "child": "popAndAppend",
       "parent": symbol {
        "content": "appended"
        }
       }
      }
     },
    "arguments": [method-access {
     "child": "left",
     "parent": symbol {
      "content": "Tuple"
      }
     }]
    }
   }, whitespace {
   }],
  "modifiers": [modifier {
   "modifier-value": "private"
   }, modifier {
   "modifier-value": "static"
   }],
  "params": [definition {
   "name": "current",
   "returns": symbol {
    "value": "BufferedState"
    }
   }, definition {
   "name": "c",
   "returns": symbol {
    "value": "char"
    }
   }]
  }, method {
  "name": "processDoubleQuotes",
  "returns": generic {
   "base": symbol {
    "value": "Optional"
    },
   "children": [symbol {
    "value": "BufferedState"
    }]
   },
  "children": [if {
   "content": " (c != '\"') return Optional.empty();"
   }, declaration {
   "name": "current",
   "caller": property-access {
    "child": "append",
    "parent": symbol {
     "content": "state"
     }
    },
   "returns": symbol {
    "value": "var"
    },
   "arguments": [symbol {
    "content": "c"
    }]
   }, while {
   "content": " (true) {
            var processed = processInDoubleQuotes(current);
            if (processed.isEmpty()) return Optional.of(current);
            current = processed.get();
        }"
   }, whitespace {
   }],
  "modifiers": [modifier {
   "modifier-value": "private"
   }, modifier {
   "modifier-value": "static"
   }],
  "params": [definition {
   "name": "state",
   "returns": symbol {
    "value": "BufferedState"
    }
   }, definition {
   "name": "c",
   "returns": symbol {
    "value": "char"
    }
   }]
  }, method {
  "name": "processInDoubleQuotes",
  "returns": generic {
   "base": symbol {
    "value": "Optional"
    },
   "children": [symbol {
    "value": "BufferedState"
    }]
   },
  "children": [declaration {
   "name": "optional",
   "caller": property-access {
    "child": "popAndAppend",
    "parent": symbol {
     "content": "current"
     }
    },
   "returns": symbol {
    "value": "var"
    },
   "modifiers": [modifier {
    "modifier-value": "final"
    }]
   }, if {
   "content": " (optional.isEmpty()) return Optional.empty();"
   }, declaration {
   "name": "next",
   "caller": property-access {
    "child": "get",
    "parent": symbol {
     "content": "optional"
     }
    },
   "returns": symbol {
    "value": "var"
    },
   "modifiers": [modifier {
    "modifier-value": "final"
    }]
   }, declaration {
   "name": "nextState",
   "caller": property-access {
    "child": "left",
    "parent": symbol {
     "content": "next"
     }
    },
   "returns": symbol {
    "value": "var"
    },
   "modifiers": [modifier {
    "modifier-value": "final"
    }]
   }, declaration {
   "name": "nextChar",
   "caller": property-access {
    "child": "right",
    "parent": symbol {
     "content": "next"
     }
    },
   "returns": symbol {
    "value": "var"
    },
   "modifiers": [modifier {
    "modifier-value": "final"
    }]
   }, if {
   "content": " (nextChar == '\\') {
            return Optional.of(nextState
                    .popAndAppend()
                    .map(Tuple::left)
                    .orElse(nextState));
        }"
   }, if {
   "content": " (nextChar == '\"') {
            return Optional.empty();
        }"
   }, return {
   "value": invocation {
    "caller": property-access {
     "child": "of",
     "parent": symbol {
      "content": "Optional"
      }
     },
    "arguments": [symbol {
     "content": "nextState"
     }]
    }
   }, whitespace {
   }],
  "modifiers": [modifier {
   "modifier-value": "private"
   }, modifier {
   "modifier-value": "static"
   }],
  "params": [definition {
   "name": "current",
   "returns": symbol {
    "value": "BufferedState"
    }
   }]
  }, method {
  "name": "split",
  "returns": generic {
   "base": symbol {
    "value": "List"
    },
   "children": [symbol {
    "value": "String"
    }]
   },
  "children": [declaration {
   "name": "length",
   "caller": property-access {
    "child": "length",
    "parent": symbol {
     "content": "input"
     }
    },
   "returns": symbol {
    "value": "var"
    },
   "modifiers": [modifier {
    "modifier-value": "final"
    }]
   }, declaration {
   "name": "queue",
   "caller": property-access {
    "child": "collect",
    "parent": invocation {
     "caller": property-access {
      "child": "mapToObj",
      "parent": invocation {
       "caller": property-access {
        "child": "range",
        "parent": symbol {
         "content": "IntStream"
         }
        },
       "arguments": [number {
        "value": "0"
        }, symbol {
        "content": "length"
        }]
       }
      },
     "arguments": [method-access {
      "child": "charAt",
      "parent": symbol {
       "content": "input"
       }
      }]
     }
    },
   "returns": symbol {
    "value": "var"
    },
   "arguments": [invocation {
    "caller": property-access {
     "child": "toCollection",
     "parent": symbol {
      "content": "Collectors"
      }
     },
    "arguments": [method-access {
     "child": "new",
     "parent": symbol {
      "content": "LinkedList"
      }
     }]
    }]
   }, declaration {
   "name": "current",
   "caller": symbol {
    "content": "BufferedState"
    },
   "returns": symbol {
    "value": "var"
    },
   "arguments": [symbol {
    "content": "queue"
    }]
   }, while {
   "content": " (true) {
            final var popped = current.pop();
            if (popped.isEmpty()) break;

            var c = popped.get().right();
            current = splitAtChar(current, c);
        }"
   }, return {
   "value": invocation {
    "caller": property-access {
     "child": "collect",
     "parent": invocation {
      "caller": property-access {
       "child": "stream",
       "parent": invocation {
        "caller": property-access {
         "child": "advance",
         "parent": symbol {
          "content": "current"
          }
         }
        }
       }
      }
     },
    "arguments": [invocation {
     "caller": property-access {
      "child": "asList",
      "parent": symbol {
       "content": "JavaCollectors"
       }
      }
     }]
    }
   }, whitespace {
   }],
  "annotations": [annotation {
   "value": "Override"
   }],
  "modifiers": [modifier {
   "modifier-value": "public"
   }],
  "params": [definition {
   "name": "input",
   "returns": symbol {
    "value": "String"
    }
   }]
  }, whitespace {
  }],
 "modifiers": [modifier {
  "modifier-value": "public"
  }]
 }, whitespace {
 }]
}