{
"children": [package {
 "namespace": ["magma", "app", "compile"]
 }, import {
 "namespace": ["magma", "api", "result", "Err"]
 }, import {
 "namespace": ["magma", "api", "result", "Ok"]
 }, import {
 "namespace": ["magma", "api", "result", "Result"]
 }, import {
 "namespace": ["magma", "app", "compile", "lang", "JavaLang"]
 }, import {
 "namespace": ["magma", "app", "compile", "lang", "MagmaLang"]
 }, import {
 "namespace": ["magma", "app", "compile", "rule", "RuleResult"]
 }, import {
 "namespace": ["java", "util", "ArrayList"]
 }, import {
 "namespace": ["java", "util", "List"]
 }, import {
 "namespace": ["java", "util", "Optional"]
 }, import {
 "namespace": ["static magma", "app", "compile", "lang", "CommonLang", "CHILDREN"]
 }, import {
 "namespace": ["static magma", "app", "compile", "lang", "JavaLang", "*"]
 }, import {
 "namespace": ["static magma", "app", "compile", "lang", "MagmaLang", "FUNCTION"]
 }, record {
 "name": "Compiler",
 "modifiers": [modifier {
  "content": "public"
  }],
 "params": [definition {
  "name": "input",
  "type": symbol {
   "type": "String"
   }
  }],
 "children": [method {
  "name": "pass",
  "params": definition {
   "name": "node",
   "type": symbol {
    "type": "Node"
    }
   },
  "returns": symbol {
   "type": "private static Node"
   },
  "children": [return {
   "value": invocation {
    "caller": access {
     "name": "mapNodeList",
     "parent": symbol {
      "content": "node"
      }
     },
    "arguments": [symbol {
     "content": "CHILDREN"
     }, access {
     "name": "orElse(node",
     "parent": symbol {
      "content": " Compiler::passChildren)"
      }
     }]
    }
   }]
  }, method {
  "name": "passChildren",
  "params": definition {
   "name": "children",
   "type": generic {
    "base": symbol {
     "type": "List"
     },
    "children": [symbol {
     "type": "Node"
     }]
    }
   },
  "returns": generic {
   "base": symbol {
    "type": "private static List"
    },
   "children": [symbol {
    "type": "Node"
    }]
   },
  "children": [return {
   "value": invocation {
    "caller": access {
     "name": "stream",
     "parent": symbol {
      "content": "children"
      }
     },
    "arguments": [access {
     "name": "toList(",
     "parent": access {
      "name": "map(Compiler::passRootChild)
                ",
      "parent": access {
       "name": "PACKAGE))
                ",
       "parent": access {
        "name": "is(JavaLang",
        "parent": access {
         "name": "filter(child -> !child",
         "parent": symbol {
          "content": ")
                "
          }
         }
        }
       }
      }
     }]
    }
   }]
  }, method {
  "name": "passRootChild",
  "params": definition {
   "name": "node",
   "type": symbol {
    "type": "Node"
    }
   },
  "returns": symbol {
   "type": "private static Node"
   },
  "children": [return {
   "value": invocation {
    "caller": symbol {
     "content": "passRecord"
     },
    "arguments": [access {
     "name": "orElse(node",
     "parent": access {
      "name": "or(() -> passClass(node))
                ",
      "parent": access {
       "name": "or(() -> passInterface(node))
                ",
       "parent": symbol {
        "content": "node)
                "
        }
       }
      }
     }]
    }
   }]
  }, method {
  "name": "passClass",
  "params": definition {
   "name": "node",
   "type": symbol {
    "type": "Node"
    }
   },
  "returns": generic {
   "base": symbol {
    "type": "private static Optional"
    },
   "children": [symbol {
    "type": "? extends Node"
    }]
   },
  "children": [symbol {
   "content": "if (node.is(CLASS)) {
            return Optional.of(node.retype(FUNCTION));
        }"
   }, symbol {
   "content": "else {
            return Optional.empty();
        }"
   }]
  }, method {
  "name": "passRecord",
  "params": definition {
   "name": "node",
   "type": symbol {
    "type": "Node"
    }
   },
  "returns": generic {
   "base": symbol {
    "type": "private static Optional"
    },
   "children": [symbol {
    "type": "Node"
    }]
   },
  "children": [return {
   "value": invocation {
    "caller": access {
     "name": "is",
     "parent": symbol {
      "content": "node"
      }
     },
    "arguments": [access {
     "name": "empty(",
     "parent": access {
      "name": "retype(FUNCTION)) : Optional",
      "parent": access {
       "name": "of(node",
       "parent": symbol {
        "content": "RECORD) ? Optional"
        }
       }
      }
     }]
    }
   }]
  }, method {
  "name": "passInterface",
  "params": definition {
   "name": "node",
   "type": symbol {
    "type": "Node"
    }
   },
  "returns": generic {
   "base": symbol {
    "type": "private static Optional"
    },
   "children": [symbol {
    "type": "Node"
    }]
   },
  "children": [symbol {
   "content": "if (!node.is(INTERFACE)) return Optional.empty();"
   }, symbol {
   "content": "final var retype = node.retype(MagmaLang.TRAIT);"
   }, symbol {
   "content": "final var withModifiers = retype.mapStringList(MODIFIERS, modifiers -> {
            var newList = new ArrayList<String>();
            if (modifiers.contains("public")) newList.add("export");
            return newList;
        }"
   }, symbol {
   "content": ").orElse(retype);"
   }, symbol {
   "content": "final var withChildren = withModifiers.mapNodeList(CHILDREN, children -> children.stream()
                .map(Compiler::passClassMember)
                .toList()).orElse(withModifiers);"
   }, return {
   "value": invocation {
    "caller": access {
     "name": "of",
     "parent": symbol {
      "content": "Optional"
      }
     },
    "arguments": [symbol {
     "content": "withChildren"
     }]
    }
   }]
  }, method {
  "name": "passClassMember",
  "params": definition {
   "name": "child",
   "type": symbol {
    "type": "Node"
    }
   },
  "returns": symbol {
   "type": "private static Node"
   },
  "children": [symbol {
   "content": "if (child.is(METHOD)) return child.retype(FUNCTION);"
   }, return {
   "value": symbol {
    "content": "child"
    }
   }]
  }, method {
  "name": "compile",
  "returns": generic {
   "base": symbol {
    "type": "public Result"
    },
   "children": [symbol {
    "type": "CompileResult"
    }, symbol {
    "type": "CompileException"
    }]
   },
  "children": [symbol {
   "content": "final var parsed = createRootRule().parse(input);"
   }, symbol {
   "content": "return write(parsed).flatMapValue(beforePass -> {
            final var afterPass = pass(beforePass);
            final var generated = MagmaLang.createRootRule().generate(afterPass);
            return write(generated).mapValue(output -> new CompileResult(beforePass, afterPass, output));
        }"
   }, symbol {
   "content": ");"
   }]
  }, method {
  "name": "write",
  "params": definition {
   "name": "result",
   "type": generic {
    "base": symbol {
     "type": "RuleResult"
     },
    "children": [symbol {
     "type": "T"
     }, symbol {
     "type": "E"
     }]
    }
   },
  "returns": generic {
   "base": symbol {
    "type": "private"
    },
   "children": [symbol {
    "type": "T"
    }, symbol {
    "type": "E extends Exception> Result<T"
    }, symbol {
    "type": "CompileException"
    }]
   },
  "children": [symbol {
   "content": "if (result.isValid()) {
            return new Ok<>(result.result().findValue().orElseThrow());
        }"
   }, symbol {
   "content": "else {
            writeResult(result, 0, 0);
            return new Err<>(new CompileException());
        }"
   }]
  }, method {
  "name": "writeResult",
  "params": definition {
   "name": "index",
   "type": symbol {
    "type": "RuleResult<T, E> result, int depth, int"
    }
   },
  "returns": symbol {
   "type": "private <T, E extends Exception> void"
   },
  "children": [symbol {
   "content": "final var error = result.result().findError();"
   }, symbol {
   "content": "if (error.isPresent()) {
            final var repeat = " ".repeat(depth);
            final var s = (index + 1) + ") ";
            final var rawMessage = error.get().getMessage();
            final var message = rawMessage.replaceAll("\r\n", "\r\n" + repeat + " ".repeat(s.length()));
            System.out.println(repeat + s + message);
        }"
   }, symbol {
   "content": "List<RuleResult<T, E>> children = result.sortedChildren();"
   }, symbol {
   "content": "for (int i = 0;"
   }, symbol {
   "content": "i < children.size();"
   }, symbol {
   "content": "i++) {
            RuleResult<T, E> child = children.get(i);
            writeResult(child, depth + 1, i);
        }"
   }]
  }]
 }]
}