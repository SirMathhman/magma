{
"children": [package {
 "namespace": "magma.app.compile.rule"
 }, import {
 "namespace": "magma.api.result.Err"
 }, import {
 "namespace": "magma.app.compile.GenerateException"
 }, import {
 "namespace": "magma.app.compile.Node"
 }, import {
 "namespace": "magma.app.compile.ParseException"
 }, class {
 "name": "LocatingRule implements Rule ",
 "body": "
    private final Rule leftRule;
    private final Rule rightRule;
    private final Locator locator;

    public LocatingRule(Rule leftRule, Locator locator, Rule rightRule) {
        this.leftRule = leftRule;
        this.rightRule = rightRule;
        this.locator = locator;
    }

    @Override
    public RuleResult<Node, ParseException> parse(String input) {
        final var optional = locator.locate(input);
        if (optional.isEmpty())
            return new RuleResult<>(new Err<>(new ParseException("Slice '" + locator.slice() + "' not present", input)));

        final int index = optional.get();
        final var left = input.substring(0, index);
        final var right = input.substring(index + locator.slice().length());

        final var leftResult = leftRule.parse(left);
        if (leftResult.isError()) return leftResult.wrapErr(new ParseException("Invalid left", left));

        final var rightResult = rightRule.parse(right);
        if (rightResult.isError()) return rightResult.wrapErr(new ParseException("Invalid right", right));

        return new RuleResult<>(leftResult.result().and(rightResult::result).mapValue(tuple -> tuple.left().merge(tuple.right())));
    }


    @Override
    public RuleResult<String, GenerateException> generate(Node node) {
        final var leftResult = leftRule.generate(node);
        if (leftResult.isError()) return leftResult.wrapErr(new GenerateException("Invalid left", node));

        final var rightResult = rightRule.generate(node);
        if (rightResult.isError()) return rightResult.wrapErr(new GenerateException("Invalid right", node));

        return new RuleResult<>(leftResult.result().and(rightResult::result).mapValue(tuple -> tuple.left() + locator.slice() + tuple.right()));
    }
}",
 "before-keyword": "public final "
 }]
}