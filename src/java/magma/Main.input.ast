group {
	"children": [package {
		"namespace": ["magma"]
	}, import {
		"namespace": ["magma", "api", "JavaFiles"]
	}, import {
		"namespace": ["magma", "api", "Tuple"]
	}, import {
		"namespace": ["magma", "api", "result", "Err"]
	}, import {
		"namespace": ["magma", "api", "result", "Ok"]
	}, import {
		"namespace": ["magma", "api", "result", "Result"]
	}, import {
		"namespace": ["magma", "compile", "Node"]
	}, import {
		"namespace": ["magma", "compile", "error", "ApplicationError"]
	}, import {
		"namespace": ["magma", "compile", "error", "JavaError"]
	}, import {
		"namespace": ["magma", "compile", "lang", "CLang"]
	}, import {
		"namespace": ["magma", "compile", "lang", "JavaLang"]
	}, import {
		"namespace": ["java", "nio", "file", "Path"]
	}, import {
		"namespace": ["java", "nio", "file", "Paths"]
	}, import {
		"namespace": ["java", "util", "ArrayList"]
	}, import {
		"namespace": ["java", "util", "Collections"]
	}, import {
		"namespace": ["java", "util", "List"]
	}, import {
		"namespace": ["java", "util", "Optional"]
	}, import {
		"namespace": ["java", "util", "function", "BiFunction"]
	}, import {
		"namespace": ["java", "util", "stream", "Collectors"]
	}, class {
		"before-keyword": "public ", 
		"name": "Main", 
		"value": block {
			"value": group {
				"children": [method {
					"name": "main", 
					"modifiers": ["public", "static"], 
					"type": symbol {
						"value": "void"
					}, 
					"value": block {
						"value": group {
							"children": [initialization {
								"definition": definition {
									"name": "source", 
									"modifiers": ["final"], 
									"type": symbol {
										"value": "Path"
									}
								}, 
								"value": invocation {
									"caller": " Paths.get", 
									"arguments": "".", "src", "java", "magma", "Main.java""
								}
							}, invocation {
								"caller": "JavaFiles.readString", 
								"arguments": "source)\n                .mapErr(JavaError::new)\n                .mapErr(ApplicationError::new)\n                .match(input -> runWithInput(source, input), Optional::of)\n                .ifPresent(error -> System.err.println(error.display())"
							}]
						}
					}, 
					"params": [definition {
						"name": "args", 
						"type": array {
							"child": symbol {
								"value": "String"
							}
						}
					}]
				}, method {
					"name": "runWithInput", 
					"modifiers": ["private", "static"], 
					"type": generic {
						"parent": "Optional", 
						"children": [symbol {
							"value": "ApplicationError"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [invocation {
								"caller": "return JavaLang.createJavaRootRule", 
								"arguments": ")\n                .parse(input)\n                .mapErr(ApplicationError::new)\n                .flatMapValue(parsed -> {\n                    return JavaFiles.writeString(source.resolveSibling("Main.input.ast"), parsed.toString())\n                            .map(JavaError::new)\n                            .map(ApplicationError::new)\n                            .<Result<Node, ApplicationError>>map(Err::new)\n                            .orElseGet(() -> new Ok<>(parsed));\n                })\n                .mapValue(node -> pass(new State(), node, Tuple::new, Main::modify).right())\n                .mapValue(node -> pass(new State(), node, Main::formatBefore, Main::formatAfter).right())\n                .flatMapValue(parsed -> CLang.createCRootRule().generate(parsed).mapErr(ApplicationError::new))\n                .mapValue(generated -> writeGenerated(generated, source.resolveSibling("Main.c"))).match(value -> value, Optional::of"
							}]
						}
					}, 
					"params": [definition {
						"name": "source", 
						"type": symbol {
							"value": "Path"
						}
					}, definition {
						"name": "input", 
						"type": symbol {
							"value": "String"
						}
					}]
				}, method {
					"name": "formatBefore", 
					"modifiers": ["private", "static"], 
					"type": generic {
						"parent": "Tuple", 
						"children": [symbol {
							"value": "State"
						}, symbol {
							"value": "Node"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [if {
								"condition": invocation {
									"caller": "node.is", 
									"arguments": ""block""
								}, 
								"value": block {
									"value": group {
										"children": [invocation {
											"caller": "return new Tuple<>", 
											"arguments": "state.enter(), node"
										}]
									}
								}
							}, invocation {
								"caller": "return new Tuple<>", 
								"arguments": "state, node"
							}]
						}
					}, 
					"params": [definition {
						"name": "state", 
						"type": symbol {
							"value": "State"
						}
					}, definition {
						"name": "node", 
						"type": symbol {
							"value": "Node"
						}
					}]
				}, method {
					"name": "formatAfter", 
					"modifiers": ["private", "static"], 
					"type": generic {
						"parent": "Tuple", 
						"children": [symbol {
							"value": "State"
						}, symbol {
							"value": "Node"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [if {
								"condition": invocation {
									"caller": "node.is", 
									"arguments": ""group""
								}, 
								"value": block {
									"value": group {
										"children": [initialization {
											"definition": definition {
												"name": "oldChildren", 
												"modifiers": ["final"], 
												"type": symbol {
													"value": "var"
												}
											}, 
											"value": invocation {
												"caller": " node.findNodeList", 
												"arguments": ""children""
											}
										}, initialization {
											"definition": definition {
												"name": "newChildren", 
												"modifiers": ["final"], 
												"type": symbol {
													"value": "var"
												}
											}, 
											"value": invocation {
												"caller": " new ArrayList<Node>", 
												"arguments": ""
											}
										}, initialization {
											"definition": definition {
												"name": "orElse", 
												"type": generic {
													"parent": "List", 
													"children": [symbol {
														"value": "Node"
													}]
												}
											}, 
											"value": invocation {
												"caller": " oldChildren.orElse", 
												"arguments": "Collections.emptyList()"
											}
										}, initialization {
											"definition": definition {
												"name": "i", 
												"type": symbol {
													"value": "int"
												}
											}, 
											"value": number {
												"value": "0"
											}
										}, while {
											"condition": invocation {
												"caller": "i < orElse.size", 
												"arguments": ""
											}, 
											"value": block {
												"value": group {
													"children": [initialization {
														"definition": definition {
															"name": "child", 
															"type": symbol {
																"value": "Node"
															}
														}, 
														"value": invocation {
															"caller": " orElse.get", 
															"arguments": "i"
														}
													}, initialization {
														"definition": definition {
															"name": "withString", 
															"modifiers": ["final"], 
															"type": symbol {
																"value": "var"
															}
														}, 
														"value": invocation {
															"caller": " getNode", 
															"arguments": "state, i, child"
														}
													}, invocation {
														"caller": "newChildren.add", 
														"arguments": "withString"
													}, assignment {
														"destination": "i ", 
														"source": " i + 1"
													}]
												}
											}
										}, invocation {
											"caller": "return new Tuple<>", 
											"arguments": "state, node\n                    .withNodeList("children", newChildren)\n                    .withString("after-children", "\n" + "\t".repeat(Math.max(state.depth() - 1, 0)))"
										}]
									}
								}
							}, else {
								"value": if {
									"condition": invocation {
										"caller": "node.is", 
										"arguments": ""block""
									}, 
									"value": block {
										"value": group {
											"children": [invocation {
												"caller": "return new Tuple<>", 
												"arguments": "state.exit(), node"
											}]
										}
									}
								}
							}, else {
								"value": block {
									"value": group {
										"children": [invocation {
											"caller": "return new Tuple<>", 
											"arguments": "state, node"
										}]
									}
								}
							}]
						}
					}, 
					"params": [definition {
						"name": "state", 
						"type": symbol {
							"value": "State"
						}
					}, definition {
						"name": "node", 
						"type": symbol {
							"value": "Node"
						}
					}]
				}, method {
					"name": "getNode", 
					"modifiers": ["private", "static"], 
					"type": symbol {
						"value": "Node"
					}, 
					"value": block {
						"value": group {
							"children": [assignment {
								"destination": "if (state.depth() ", 
								"source": "= 0 && i == 0) return child"
							}, initialization {
								"definition": definition {
									"name": "indent", 
									"modifiers": ["final"], 
									"type": symbol {
										"value": "var"
									}
								}, 
								"value": invocation {
									"caller": " "\n" + "\t".repeat", 
									"arguments": "state.depth()"
								}
							}, invocation {
								"caller": "return child.withString", 
								"arguments": ""before-child", indent"
							}]
						}
					}, 
					"params": [definition {
						"name": "state", 
						"type": symbol {
							"value": "State"
						}
					}, definition {
						"name": "i", 
						"type": symbol {
							"value": "int"
						}
					}, definition {
						"name": "child", 
						"type": symbol {
							"value": "Node"
						}
					}]
				}, method {
					"name": "pass", 
					"modifiers": ["private", "static"], 
					"type": generic {
						"parent": "Tuple", 
						"children": [symbol {
							"value": "State"
						}, symbol {
							"value": "Node"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [initialization {
								"definition": definition {
									"name": "withBefore", 
									"modifiers": ["final"], 
									"type": symbol {
										"value": "var"
									}
								}, 
								"value": invocation {
									"caller": " beforePass.apply", 
									"arguments": "state, node"
								}
							}, initialization {
								"definition": definition {
									"name": "withNodeLists", 
									"modifiers": ["final"], 
									"type": symbol {
										"value": "var"
									}
								}, 
								"value": invocation {
									"caller": " withBefore.right", 
									"arguments": ")\n                .streamNodeLists()\n                .reduce(withBefore, (node1, tuple) -> passNodeLists(node1, tuple, beforePass, afterPass), (_, next) -> next"
								}
							}, initialization {
								"definition": definition {
									"name": "withNodes", 
									"modifiers": ["final"], 
									"type": symbol {
										"value": "var"
									}
								}, 
								"value": invocation {
									"caller": " withNodeLists.right", 
									"arguments": ")\n                .streamNodes()\n                .reduce(withNodeLists, (node1, tuple) -> passNode(node1, tuple, beforePass, afterPass), (_, next) -> next"
								}
							}, invocation {
								"caller": "return afterPass.apply", 
								"arguments": "withNodes.left(), withNodes.right()"
							}]
						}
					}, 
					"params": [definition {
						"name": "state", 
						"type": symbol {
							"value": "State"
						}
					}, definition {
						"name": "node", 
						"type": symbol {
							"value": "Node"
						}
					}, definition {
						"name": "beforePass", 
						"type": generic {
							"parent": "BiFunction", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}, generic {
								"parent": "Tuple", 
								"children": [symbol {
									"value": "State"
								}, symbol {
									"value": "Node"
								}]
							}]
						}
					}, definition {
						"name": "afterPass", 
						"type": generic {
							"parent": "BiFunction", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}, generic {
								"parent": "Tuple", 
								"children": [symbol {
									"value": "State"
								}, symbol {
									"value": "Node"
								}]
							}]
						}
					}]
				}, method {
					"name": "passNode", 
					"modifiers": ["private", "static"], 
					"type": generic {
						"parent": "Tuple", 
						"children": [symbol {
							"value": "State"
						}, symbol {
							"value": "Node"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [initialization {
								"definition": definition {
									"name": "oldState", 
									"modifiers": ["final"], 
									"type": symbol {
										"value": "var"
									}
								}, 
								"value": invocation {
									"caller": " current.left", 
									"arguments": ""
								}
							}, initialization {
								"definition": definition {
									"name": "oldNode", 
									"modifiers": ["final"], 
									"type": symbol {
										"value": "var"
									}
								}, 
								"value": invocation {
									"caller": " current.right", 
									"arguments": ""
								}
							}, initialization {
								"definition": definition {
									"name": "key", 
									"modifiers": ["final"], 
									"type": symbol {
										"value": "var"
									}
								}, 
								"value": invocation {
									"caller": " entry.left", 
									"arguments": ""
								}
							}, initialization {
								"definition": definition {
									"name": "value", 
									"modifiers": ["final"], 
									"type": symbol {
										"value": "var"
									}
								}, 
								"value": invocation {
									"caller": " entry.right", 
									"arguments": ""
								}
							}, invocation {
								"caller": "return pass", 
								"arguments": "oldState, value, beforePass, afterPass).mapRight(right -> oldNode.withNode(key, right)"
							}]
						}
					}, 
					"params": [definition {
						"name": "current", 
						"type": generic {
							"parent": "Tuple", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}]
						}
					}, definition {
						"name": "entry", 
						"type": generic {
							"parent": "Tuple", 
							"children": [symbol {
								"value": "String"
							}, symbol {
								"value": "Node"
							}]
						}
					}, definition {
						"name": "beforePass", 
						"type": generic {
							"parent": "BiFunction", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}, generic {
								"parent": "Tuple", 
								"children": [symbol {
									"value": "State"
								}, symbol {
									"value": "Node"
								}]
							}]
						}
					}, definition {
						"name": "afterPass", 
						"type": generic {
							"parent": "BiFunction", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}, generic {
								"parent": "Tuple", 
								"children": [symbol {
									"value": "State"
								}, symbol {
									"value": "Node"
								}]
							}]
						}
					}]
				}, method {
					"name": "passNodeLists", 
					"modifiers": ["private", "static"], 
					"type": generic {
						"parent": "Tuple", 
						"children": [symbol {
							"value": "State"
						}, symbol {
							"value": "Node"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [initialization {
								"definition": definition {
									"name": "oldState", 
									"modifiers": ["final"], 
									"type": symbol {
										"value": "var"
									}
								}, 
								"value": invocation {
									"caller": " current.left", 
									"arguments": ""
								}
							}, initialization {
								"definition": definition {
									"name": "oldChildren", 
									"modifiers": ["final"], 
									"type": symbol {
										"value": "var"
									}
								}, 
								"value": invocation {
									"caller": " current.right", 
									"arguments": ""
								}
							}, initialization {
								"definition": definition {
									"name": "key", 
									"modifiers": ["final"], 
									"type": symbol {
										"value": "var"
									}
								}, 
								"value": invocation {
									"caller": " entry.left", 
									"arguments": ""
								}
							}, initialization {
								"definition": definition {
									"name": "values", 
									"modifiers": ["final"], 
									"type": symbol {
										"value": "var"
									}
								}, 
								"value": invocation {
									"caller": " entry.right", 
									"arguments": ""
								}
							}, assignment {
								"destination": "var currentState ", 
								"source": " oldState"
							}, initialization {
								"definition": definition {
									"name": "currentChildren", 
									"type": symbol {
										"value": "var"
									}
								}, 
								"value": invocation {
									"caller": " new ArrayList<Node>", 
									"arguments": ""
								}
							}, initialization {
								"definition": definition {
									"name": "i", 
									"type": symbol {
										"value": "int"
									}
								}, 
								"value": number {
									"value": "0"
								}
							}, while {
								"condition": invocation {
									"caller": "i < values.size", 
									"arguments": ""
								}, 
								"value": block {
									"value": group {
										"children": [initialization {
											"definition": definition {
												"name": "value", 
												"type": symbol {
													"value": "Node"
												}
											}, 
											"value": invocation {
												"caller": " values.get", 
												"arguments": "i"
											}
										}, initialization {
											"definition": definition {
												"name": "passed", 
												"modifiers": ["final"], 
												"type": symbol {
													"value": "var"
												}
											}, 
											"value": invocation {
												"caller": " pass", 
												"arguments": "currentState, value, beforePass, afterPass"
											}
										}, invocation {
											"caller": "currentState = passed.left", 
											"arguments": ""
										}, invocation {
											"caller": "currentChildren.add", 
											"arguments": "passed.right()"
										}, assignment {
											"destination": "i ", 
											"source": " i + 1"
										}]
									}
								}
							}, initialization {
								"definition": definition {
									"name": "newNode", 
									"modifiers": ["final"], 
									"type": symbol {
										"value": "var"
									}
								}, 
								"value": invocation {
									"caller": " oldChildren.withNodeList", 
									"arguments": "key, currentChildren"
								}
							}, invocation {
								"caller": "return new Tuple<>", 
								"arguments": "oldState, newNode"
							}]
						}
					}, 
					"params": [definition {
						"name": "current", 
						"type": generic {
							"parent": "Tuple", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}]
						}
					}, definition {
						"name": "entry", 
						"type": generic {
							"parent": "Tuple", 
							"children": [symbol {
								"value": "String"
							}, generic {
								"parent": "List", 
								"children": [symbol {
									"value": "Node"
								}]
							}]
						}
					}, definition {
						"name": "beforePass", 
						"type": generic {
							"parent": "BiFunction", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}, generic {
								"parent": "Tuple", 
								"children": [symbol {
									"value": "State"
								}, symbol {
									"value": "Node"
								}]
							}]
						}
					}, definition {
						"name": "afterPass", 
						"type": generic {
							"parent": "BiFunction", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}, generic {
								"parent": "Tuple", 
								"children": [symbol {
									"value": "State"
								}, symbol {
									"value": "Node"
								}]
							}]
						}
					}]
				}, method {
					"name": "modify", 
					"modifiers": ["private", "static"], 
					"type": generic {
						"parent": "Tuple", 
						"children": [symbol {
							"value": "State"
						}, symbol {
							"value": "Node"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [initialization {
								"definition": definition {
									"name": "result", 
									"modifiers": ["final"], 
									"type": symbol {
										"value": "var"
									}
								}, 
								"value": invocation {
									"caller": " modifyStateless", 
									"arguments": "node"
								}
							}, invocation {
								"caller": "return new Tuple<>", 
								"arguments": "state, result"
							}]
						}
					}, 
					"params": [definition {
						"name": "state", 
						"type": symbol {
							"value": "State"
						}
					}, definition {
						"name": "node", 
						"type": symbol {
							"value": "Node"
						}
					}]
				}, method {
					"name": "modifyStateless", 
					"modifiers": ["private", "static"], 
					"type": symbol {
						"value": "Node"
					}, 
					"value": block {
						"value": group {
							"children": [if {
								"condition": invocation {
									"caller": "node.is", 
									"arguments": ""group""
								}, 
								"value": block {
									"value": group {
										"children": [initialization {
											"definition": definition {
												"name": "oldChildren", 
												"modifiers": ["final"], 
												"type": symbol {
													"value": "var"
												}
											}, 
											"value": invocation {
												"caller": " node.findNodeList", 
												"arguments": ""children").orElse(new ArrayList<>()"
											}
										}, initialization {
											"definition": definition {
												"name": "newChildren", 
												"modifiers": ["final"], 
												"type": symbol {
													"value": "var"
												}
											}, 
											"value": invocation {
												"caller": " oldChildren.stream", 
												"arguments": ")\n                    .filter(oldChild -> !oldChild.is("package"))\n                    .collect(Collectors.toCollection(ArrayList::new)"
											}
										}, invocation {
											"caller": "return node.withNodeList", 
											"arguments": ""children", newChildren"
										}]
									}
								}
							}, else {
								"value": if {
									"condition": invocation {
										"caller": "node.is", 
										"arguments": ""class""
									}, 
									"value": block {
										"value": group {
											"children": [invocation {
												"caller": "return node.retype", 
												"arguments": ""struct""
											}]
										}
									}
								}
							}, else {
								"value": if {
									"condition": invocation {
										"caller": "node.is", 
										"arguments": ""import""
									}, 
									"value": block {
										"value": group {
											"children": [invocation {
												"caller": "return node.retype", 
												"arguments": ""include""
											}]
										}
									}
								}
							}, else {
								"value": if {
									"condition": invocation {
										"caller": "node.is", 
										"arguments": ""method""
									}, 
									"value": block {
										"value": group {
											"children": [invocation {
												"caller": "return node.retype", 
												"arguments": ""function""
											}]
										}
									}
								}
							}, else {
								"value": block {
									"value": group {
										"children": [return {
											"value": "node"
										}]
									}
								}
							}]
						}
					}, 
					"params": [definition {
						"name": "node", 
						"type": symbol {
							"value": "Node"
						}
					}]
				}, method {
					"name": "writeGenerated", 
					"modifiers": ["private", "static"], 
					"type": generic {
						"parent": "Optional", 
						"children": [symbol {
							"value": "ApplicationError"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [invocation {
								"caller": "return JavaFiles.writeString", 
								"arguments": "target, generated)\n                .map(JavaError::new)\n                .map(ApplicationError::new"
							}]
						}
					}, 
					"params": [definition {
						"name": "generated", 
						"type": symbol {
							"value": "String"
						}
					}, definition {
						"name": "target", 
						"type": symbol {
							"value": "Path"
						}
					}]
				}]
			}
		}
	}, whitespace {
	}]
}