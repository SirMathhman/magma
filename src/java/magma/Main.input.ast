group {
	"children": [package {
		"namespace": ["magma"]
	}, import {
		"namespace": ["magma", "api", "JavaFiles"]
	}, import {
		"namespace": ["magma", "api", "Tuple"]
	}, import {
		"namespace": ["magma", "api", "result", "Err"]
	}, import {
		"namespace": ["magma", "api", "result", "Ok"]
	}, import {
		"namespace": ["magma", "api", "result", "Result"]
	}, import {
		"namespace": ["magma", "compile", "Node"]
	}, import {
		"namespace": ["magma", "compile", "error", "ApplicationError"]
	}, import {
		"namespace": ["magma", "compile", "error", "JavaError"]
	}, import {
		"namespace": ["magma", "compile", "lang", "CLang"]
	}, import {
		"namespace": ["magma", "compile", "lang", "JavaLang"]
	}, import {
		"namespace": ["java", "nio", "file", "Path"]
	}, import {
		"namespace": ["java", "nio", "file", "Paths"]
	}, import {
		"namespace": ["java", "util", "ArrayList"]
	}, import {
		"namespace": ["java", "util", "Collections"]
	}, import {
		"namespace": ["java", "util", "List"]
	}, import {
		"namespace": ["java", "util", "Optional"]
	}, import {
		"namespace": ["java", "util", "function", "BiFunction"]
	}, import {
		"namespace": ["java", "util", "stream", "Collectors"]
	}, class {
		"before-keyword": "public ", 
		"name": "Main", 
		"value": block {
			"value": group {
				"children": [method {
					"before-type": "public static", 
					"name": "main", 
					"type": symbol {
						"value": "void"
					}, 
					"value": block {
						"value": group {
							"children": [invocation {
								"content": "final Path source = Paths.get(".", "src", "java", "magma", "Main.java")"
							}, invocation {
								"content": "JavaFiles.readString(source)\n                .mapErr(JavaError::new)\n                .mapErr(ApplicationError::new)\n                .match(input -> runWithInput(source, input), Optional::of)\n                .ifPresent(error -> System.err.println(error.display()))"
							}]
						}
					}, 
					"params": [definition {
						"name": "args", 
						"type": array {
							"child": symbol {
								"value": "String"
							}
						}
					}]
				}, method {
					"before-type": "private static", 
					"name": "runWithInput", 
					"type": generic {
						"parent": "Optional", 
						"children": [symbol {
							"value": "ApplicationError"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [invocation {
								"content": "return JavaLang.createJavaRootRule()\n                .parse(input)\n                .mapErr(ApplicationError::new)\n                .flatMapValue(parsed -> {\n                    return JavaFiles.writeString(source.resolveSibling("Main.input.ast"), parsed.toString())\n                            .map(JavaError::new)\n                            .map(ApplicationError::new)\n                            .<Result<Node, ApplicationError>>map(Err::new)\n                            .orElseGet(() -> new Ok<>(parsed));\n                })\n                .mapValue(node -> pass(new State(), node, Tuple::new, Main::modify).right())\n                .mapValue(node -> pass(new State(), node, Main::formatBefore, Main::formatAfter).right())\n                .flatMapValue(parsed -> CLang.createCRootRule().generate(parsed).mapErr(ApplicationError::new))\n                .mapValue(generated -> writeGenerated(generated, source.resolveSibling("Main.c"))).match(value -> value, Optional::of)"
							}]
						}
					}, 
					"params": [definition {
						"name": "source", 
						"type": symbol {
							"value": "Path"
						}
					}, definition {
						"name": "input", 
						"type": symbol {
							"value": "String"
						}
					}]
				}, method {
					"before-type": "private static", 
					"name": "formatBefore", 
					"type": generic {
						"parent": "Tuple", 
						"children": [symbol {
							"value": "State"
						}, symbol {
							"value": "Node"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [if {
								"condition": invocation {
									"content": "node.is("block")"
								}, 
								"value": block {
									"value": group {
										"children": [invocation {
											"content": "return new Tuple<>(state.enter(), node)"
										}]
									}
								}
							}, invocation {
								"content": "return new Tuple<>(state, node)"
							}]
						}
					}, 
					"params": [definition {
						"name": "state", 
						"type": symbol {
							"value": "State"
						}
					}, definition {
						"name": "node", 
						"type": symbol {
							"value": "Node"
						}
					}]
				}, method {
					"before-type": "private static", 
					"name": "formatAfter", 
					"type": generic {
						"parent": "Tuple", 
						"children": [symbol {
							"value": "State"
						}, symbol {
							"value": "Node"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [if {
								"condition": invocation {
									"content": "node.is("group")"
								}, 
								"value": block {
									"value": group {
										"children": [invocation {
											"content": "final var oldChildren = node.findNodeList("children")"
										}, invocation {
											"content": "final var newChildren = new ArrayList<Node>()"
										}, invocation {
											"content": "List<Node> orElse = oldChildren.orElse(Collections.emptyList())"
										}, invocation {
											"content": "int i = 0"
										}, while {
											"condition": invocation {
												"content": "i < orElse.size()"
											}, 
											"value": block {
												"value": group {
													"children": [invocation {
														"content": "Node child = orElse.get(i)"
													}, invocation {
														"content": "Node withString"
													}, if {
														"condition": invocation {
															"content": "state.depth() == 0 && i == 0"
														}, 
														"value": block {
															"value": group {
																"children": [invocation {
																	"content": "withString = child"
																}]
															}
														}
													}, else {
														"value": block {
															"value": group {
																"children": [invocation {
																	"content": "final var indent = "\n" + "\t".repeat(state.depth())"
																}, invocation {
																	"content": "withString = child.withString("before-child", indent)"
																}]
															}
														}
													}, invocation {
														"content": "newChildren.add(withString)"
													}, invocation {
														"content": "i++"
													}]
												}
											}
										}, invocation {
											"content": "return new Tuple<>(state, node\n                    .withNodeList("children", newChildren)\n                    .withString("after-children", "\n" + "\t".repeat(Math.max(state.depth() - 1, 0))))"
										}]
									}
								}
							}, else {
								"value": if {
									"condition": invocation {
										"content": "node.is("block")"
									}, 
									"value": block {
										"value": group {
											"children": [invocation {
												"content": "return new Tuple<>(state.exit(), node)"
											}]
										}
									}
								}
							}, else {
								"value": block {
									"value": group {
										"children": [invocation {
											"content": "return new Tuple<>(state, node)"
										}]
									}
								}
							}]
						}
					}, 
					"params": [definition {
						"name": "state", 
						"type": symbol {
							"value": "State"
						}
					}, definition {
						"name": "node", 
						"type": symbol {
							"value": "Node"
						}
					}]
				}, method {
					"before-type": "private static", 
					"name": "pass", 
					"type": generic {
						"parent": "Tuple", 
						"children": [symbol {
							"value": "State"
						}, symbol {
							"value": "Node"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [invocation {
								"content": "final var withBefore = beforePass.apply(state, node)"
							}, invocation {
								"content": "final var withNodeLists = withBefore.right()\n                .streamNodeLists()\n                .reduce(withBefore, (node1, tuple) -> passNodeLists(node1, tuple, beforePass, afterPass), (_, next) -> next)"
							}, invocation {
								"content": "final var withNodes = withNodeLists.right()\n                .streamNodes()\n                .reduce(withNodeLists, (node1, tuple) -> passNode(node1, tuple, beforePass, afterPass), (_, next) -> next)"
							}, invocation {
								"content": "return afterPass.apply(withNodes.left(), withNodes.right())"
							}]
						}
					}, 
					"params": [definition {
						"name": "state", 
						"type": symbol {
							"value": "State"
						}
					}, definition {
						"name": "node", 
						"type": symbol {
							"value": "Node"
						}
					}, definition {
						"name": "beforePass", 
						"type": generic {
							"parent": "BiFunction", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}, generic {
								"parent": "Tuple", 
								"children": [symbol {
									"value": "State"
								}, symbol {
									"value": "Node"
								}]
							}]
						}
					}, definition {
						"name": "afterPass", 
						"type": generic {
							"parent": "BiFunction", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}, generic {
								"parent": "Tuple", 
								"children": [symbol {
									"value": "State"
								}, symbol {
									"value": "Node"
								}]
							}]
						}
					}]
				}, method {
					"before-type": "private static", 
					"name": "passNode", 
					"type": generic {
						"parent": "Tuple", 
						"children": [symbol {
							"value": "State"
						}, symbol {
							"value": "Node"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [invocation {
								"content": "final var oldState = current.left()"
							}, invocation {
								"content": "final var oldNode = current.right()"
							}, invocation {
								"content": "final var key = entry.left()"
							}, invocation {
								"content": "final var value = entry.right()"
							}, invocation {
								"content": "return pass(oldState, value, beforePass, afterPass).mapRight(right -> oldNode.withNode(key, right))"
							}]
						}
					}, 
					"params": [definition {
						"name": "current", 
						"type": generic {
							"parent": "Tuple", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}]
						}
					}, definition {
						"name": "entry", 
						"type": generic {
							"parent": "Tuple", 
							"children": [symbol {
								"value": "String"
							}, symbol {
								"value": "Node"
							}]
						}
					}, definition {
						"name": "beforePass", 
						"type": generic {
							"parent": "BiFunction", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}, generic {
								"parent": "Tuple", 
								"children": [symbol {
									"value": "State"
								}, symbol {
									"value": "Node"
								}]
							}]
						}
					}, definition {
						"name": "afterPass", 
						"type": generic {
							"parent": "BiFunction", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}, generic {
								"parent": "Tuple", 
								"children": [symbol {
									"value": "State"
								}, symbol {
									"value": "Node"
								}]
							}]
						}
					}]
				}, method {
					"before-type": "private static", 
					"name": "passNodeLists", 
					"type": generic {
						"parent": "Tuple", 
						"children": [symbol {
							"value": "State"
						}, symbol {
							"value": "Node"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [invocation {
								"content": "final var oldState = current.left()"
							}, invocation {
								"content": "final var oldChildren = current.right()"
							}, invocation {
								"content": "final var key = entry.left()"
							}, invocation {
								"content": "final var values = entry.right()"
							}, invocation {
								"content": "var currentState = oldState"
							}, invocation {
								"content": "var currentChildren = new ArrayList<Node>()"
							}, invocation {
								"content": "int i = 0"
							}, while {
								"condition": invocation {
									"content": "i < values.size()"
								}, 
								"value": block {
									"value": group {
										"children": [invocation {
											"content": "Node value = values.get(i)"
										}, invocation {
											"content": "final var passed = pass(currentState, value, beforePass, afterPass)"
										}, invocation {
											"content": "currentState = passed.left()"
										}, invocation {
											"content": "currentChildren.add(passed.right())"
										}, invocation {
											"content": "i++"
										}]
									}
								}
							}, invocation {
								"content": "final var newNode = oldChildren.withNodeList(key, currentChildren)"
							}, invocation {
								"content": "return new Tuple<>(oldState, newNode)"
							}]
						}
					}, 
					"params": [definition {
						"name": "current", 
						"type": generic {
							"parent": "Tuple", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}]
						}
					}, definition {
						"name": "entry", 
						"type": generic {
							"parent": "Tuple", 
							"children": [symbol {
								"value": "String"
							}, generic {
								"parent": "List", 
								"children": [symbol {
									"value": "Node"
								}]
							}]
						}
					}, definition {
						"name": "beforePass", 
						"type": generic {
							"parent": "BiFunction", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}, generic {
								"parent": "Tuple", 
								"children": [symbol {
									"value": "State"
								}, symbol {
									"value": "Node"
								}]
							}]
						}
					}, definition {
						"name": "afterPass", 
						"type": generic {
							"parent": "BiFunction", 
							"children": [symbol {
								"value": "State"
							}, symbol {
								"value": "Node"
							}, generic {
								"parent": "Tuple", 
								"children": [symbol {
									"value": "State"
								}, symbol {
									"value": "Node"
								}]
							}]
						}
					}]
				}, method {
					"before-type": "private static", 
					"name": "modify", 
					"type": generic {
						"parent": "Tuple", 
						"children": [symbol {
							"value": "State"
						}, symbol {
							"value": "Node"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [invocation {
								"content": "Node result"
							}, if {
								"condition": invocation {
									"content": "node.is("group")"
								}, 
								"value": block {
									"value": group {
										"children": [invocation {
											"content": "final var oldChildren = node.findNodeList("children").orElse(new ArrayList<>())"
										}, invocation {
											"content": "final var newChildren = oldChildren.stream()\n                    .filter(oldChild -> !oldChild.is("package"))\n                    .collect(Collectors.toCollection(ArrayList::new))"
										}, invocation {
											"content": "result = node.withNodeList("children", newChildren)"
										}]
									}
								}
							}, else {
								"value": if {
									"condition": invocation {
										"content": "node.is("class")"
									}, 
									"value": block {
										"value": group {
											"children": [invocation {
												"content": "result = node.retype("struct")"
											}]
										}
									}
								}
							}, else {
								"value": if {
									"condition": invocation {
										"content": "node.is("import")"
									}, 
									"value": block {
										"value": group {
											"children": [invocation {
												"content": "result = node.retype("include")"
											}]
										}
									}
								}
							}, else {
								"value": if {
									"condition": invocation {
										"content": "node.is("method")"
									}, 
									"value": block {
										"value": group {
											"children": [invocation {
												"content": "result = node.retype("function")"
											}]
										}
									}
								}
							}, else {
								"value": block {
									"value": group {
										"children": [invocation {
											"content": "result = node"
										}]
									}
								}
							}, invocation {
								"content": "return new Tuple<>(state, result)"
							}]
						}
					}, 
					"params": [definition {
						"name": "state", 
						"type": symbol {
							"value": "State"
						}
					}, definition {
						"name": "node", 
						"type": symbol {
							"value": "Node"
						}
					}]
				}, method {
					"before-type": "private static", 
					"name": "writeGenerated", 
					"type": generic {
						"parent": "Optional", 
						"children": [symbol {
							"value": "ApplicationError"
						}]
					}, 
					"value": block {
						"value": group {
							"children": [invocation {
								"content": "return JavaFiles.writeString(target, generated)\n                .map(JavaError::new)\n                .map(ApplicationError::new)"
							}]
						}
					}, 
					"params": [definition {
						"name": "generated", 
						"type": symbol {
							"value": "String"
						}
					}, definition {
						"name": "target", 
						"type": symbol {
							"value": "Path"
						}
					}]
				}]
			}
		}
	}, whitespace {
	}]
}