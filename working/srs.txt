1. Introduction
1.1 Purpose

    To design and implement an operating system for a custom, simulated environment using a bespoke assembly language.
    The OS will interface with programmatically defined emulated hardware.

1.2 Scope

    The OS will include a kernel, drivers for simulated hardware, task management, memory management, and a basic user interface.
    It will run in a controlled simulated environment, independent of existing architectures.

1.3 Goals

    Build the OS from scratch without relying on external libraries.
    Focus on robust hardware simulation and kernel abstractions.
    Facilitate learning and exploration of OS fundamentals.

2. System Overview
2.1 High-Level Description

    The OS will consist of:
        A boot process to initialize the kernel.
        Kernel modules for hardware interfacing, memory management, and task scheduling.
        Simulated hardware components defined programmatically.

2.2 Constraints

    Custom assembly language for all code.
    No external libraries or tools, apart from the simulation framework.

3. Functional Requirements
3.1 Kernel Initialization

    3.1.1 Boot Sequence
        Load and execute the kernel.
        Initialize CPU state and emulated hardware interfaces.
    3.1.2 Interrupt Setup
        Create an interrupt vector table to handle CPU exceptions and hardware interrupts.
        Implement a basic interrupt handling mechanism.

3.2 Simulated Hardware

    3.2.1 Emulated Components
        Define emulated hardware devices programmatically:
            Timers
            Input/Output peripherals
            Storage devices
        Map hardware registers and memory addresses.
    3.2.2 Hardware Abstractions
        Write low-level drivers in the custom assembly language to interface with these components.

3.3 Memory Management

    3.3.1 Physical Memory Manager
        Use a bitmap or linked list to track allocated and free memory blocks.
        Allocate memory for kernel tasks and user programs.
    3.3.2 Virtual Memory (Optional)
        Implement paging or segmentation if supported by the architecture.

3.4 Task Management

    3.4.1 Task Representation
        Define a data structure to store task metadata, including:
            Task ID
            State (ready, running, waiting)
            Registers and memory regions.
    3.4.2 Scheduler
        Implement a basic cooperative scheduler.
        Extend to preemptive scheduling using timer interrupts.

3.5 System Calls

    3.5.1 API Design
        Define an API for user programs to:
            Perform I/O operations.
            Access memory.
            Manage tasks.
    3.5.2 Trap Mechanism
        Implement a trap instruction or interrupt to invoke system calls.

3.6 Filesystem

    3.6.1 Storage Simulation
        Programmatically define an emulated storage device (e.g., RAM-backed or file-backed on host).
    3.6.2 Filesystem Design
        Create a custom filesystem with:
            Support for file creation, reading, and writing.
            Directory structure and metadata management.

3.7 User Interface

    3.7.1 Command-Line Interface
        Provide a CLI for executing user commands.
        Include built-in commands for basic OS functionality (e.g., listing files, running programs).
    3.7.2 Input/Output Handling
        Implement drivers for input devices (keyboard or equivalent) and display outputs.

4. Non-Functional Requirements
4.1 Performance

    The OS must handle simulated tasks efficiently within the constraints of the custom architecture.

4.2 Reliability

    The kernel must handle invalid inputs and hardware failures gracefully in the simulated environment.

4.3 Modularity

    Code for drivers, memory management, and task scheduling should be modular to allow for future extensions.

4.4 Debugging Support

    Provide debugging tools within the simulation framework, such as:
        Memory inspection.
        Execution trace logs.

5. System Architecture
5.1 Kernel

    5.1.1 Initialization Module
        Initializes the CPU and hardware devices.
    5.1.2 Core Modules
        Interrupt handling.
        Task scheduling.
        Memory management.
    5.1.3 Device Drivers
        Separate modules for each hardware device.

5.2 Hardware Simulation

    5.2.1 CPU Simulation
        Support for registers, instruction set, and interrupts.
    5.2.2 Peripheral Devices
        Emulate essential peripherals with configurable behavior.

6. Development Plan
6.1 Milestones

    Bootloader development.
    Kernel initialization and interrupt handling.
    Driver implementation for simulated hardware.
    Memory and task management.
    Filesystem and CLI.

6.2 Testing

    Use the simulation environment to validate each component.
    Implement unit tests for kernel modules and hardware interaction.

6.3 Documentation

    Maintain detailed documentation for:
        Simulated hardware specifications.
        Kernel API and internal structures.